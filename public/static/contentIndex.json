{"Blog-Posts/Keyboards/Dactyl-Manuform-R-Track":{"title":"Dactyl Manuform R-Track","links":["Blog-Posts/Keyboards/ErgoTravel","Research/Ergonomic-Mechanical-Keyboards/Ergonomic-Keyboards"],"tags":["keyboards"],"content":"Dactyl Manuform R-Track\nPreface: This design is entirely made by QQurn, and details can be found at gitlab.com/keyboards1/dm_r_track.\nAfter building my first ergonomic keyboard a few months prior, I wanted to do more electronics. I started toying with the idea of having a pointing device (something to move the mouse) integrated into the keyboard. In researching that idea, I stumbled upon an amazing design. Here are some of the key features:\n\nSplit Keyboard, 5x6 layout for 62 keys\nPMW3360 Motion Sensor Integrated under the right thumb for Trackball\nI^2C Communciation Between the Halves over RJ9\nArduino Micro on the Right, Pro Micro on the Left\nFully programmable with 32kB of flash\n\nI was enthralled, but the only way to make one was with a 3D Printer. So I purchased a 3D Printer over the holidays, and got to work setting it up. After honing in the printer, I fired it up to create the case. But that was just the beginning of the work. The shape is molded to the human hand to minimize movement and maximize comfort, which requires a 3D “keywell,” curving the keys to the fingers. This shape prevents standard printed circuit boards, which are rigid and planar.\nSo, QQurn’s design resorts to “handwiring,” where the switches are connected by dozens of individual short wires soldered in air. To make matters worse, switch matrices require a diode on each key (see here for why). You have to solder each wire in air, totaling over 200 connections. It is very tedious.\nSo, painfully, over about 20 hours, I wired all the switches, along with an I^2C bus to communicate between the two microcontrollers, and the trackball sensor. A few hours of troubleshooting and a lot of firmware tweaking later, and I have an absolutely amazing keyboard. You really can’t understand how comfortable it is until you use it for a full work day, but it was definitely worth the time, money, and effort. Now for the fun part: Photos!\n\n\nWhat Did I Learn?\nWhile I didn’t create this design myself, there was still a lot of work involved in manufacturing and wiring it. I learned a ton about 3D printing, soldering, and also the QMK firmware framework which enables the keyboard to work."},"Blog-Posts/Keyboards/ErgoTravel":{"title":"ErgoTravel","links":["Research/Ergonomic-Mechanical-Keyboards/Ergonomic-Keyboards"],"tags":["keyboards"],"content":"ErgoTravel\n\nThe ErgoTravel was my first foray into the world of Ergonomic Keyboards. For this first build, I stuck with something tried and true. I purchased a kit from an online retailer, and built it according to the instructions. While the components were all included, I had to solder everything by hand, my first major experience with soldering. It was a lot of fun.\nOnce I had everything soldered and assembled, the next step was firmware. The keyboard runs QMK, a C-based firmware framework that runs on hundreds of keyboard designs, including the ErgoTravel. The main config, describing the electrical design, was already complete, but I had to create and tweak my own keymap. The keymap determines what pressing a given key actually does. I decided to get ambitious and try out as many of QMKs features as possible, including tap dances, layers, layer-taps, and leader key. It was great to explore the firmware and learn a bit of C.\nOnce I had built the keyboard and been using it for a few weeks, a small problem became apparent: the kit didn’t come with a full case, so the PCB was partially exposed. I was slowly noticing dust and gunk accumulating, which I thought could become an issue long term. So I wanted to create a more full enclosure. Luckily, my father is a hobbyist wood-worker, so we worked together create a case of walnut. It’s beautiful, I think."},"Blog-Posts/Keyboards/Icarus":{"title":"Icarus","links":["Concepts/Programming/Programming-Languages/C-and-CPP/QMK"],"tags":["keyboards"],"content":"Icarus\nIntroduction\nI had just finished a written math assignment when I thought to myself: why should I have to compute something on my calculator, then enter it into the computer? Why isn’t the calculator directly connected to my computer? So I decided to try and solve that problem by making a numpad and calculator in one. You activate calculate mode, input your calculation, and it writes out the answer. Here’s a quick feature overview:\n\nFully Programmable with QMK firmware\nCustom PCB with onboard Cortex M4 Microprocessor\nIntegrated 128x32 OLED\nUSB-C Connection\n4x5 Mechanical Key Matrix for 20 Keys\n\nThe project has two main parts: Hardware (PCB and case) and software (actual functionality).\nHardware Development\nCircuitry\nThe microprocessor (i.e. the brain) is integrated directly into a custom PCB, along with USB circuitry, the key matrix, and a voltage regulator. The MCU runs on an external 16MHz crystal. I designed the PCB using KiCad, a free and open source CAD suite for electrical engineering. PCB development is one of my favorite parts of these keyboard projects, because its the right mix of creativity, problem solving, and research. For this board in particular I spent a lot of time reading about the STM32F4xx series and the best design practices for PCBs. Here’s the final schematic:\n\nAnd the PCB Layout:\n\nI had the PCB manufactured and some of the surface mount soldering done by JLCPCB.\nCase Design\nOnce I had a designed the PCB, I needed somewhere to put it. A few months prior I had purchased a 3D printer, so I decided to design and 3D print a case. I created the enclosure in AutoDesk Fusion 360. I tried my hand at creating a screw-less design. The stackup involves three parts:\n\nThe main plate\nThe PCB\nThe bottom plate\n\nThe PCB is attached to the main plate by the tension between the mechanical switches (which snap into the plate) and the holes in the PCB. The bottom plate then has a “snap-fit” to attach to the main plate, fulling enclosing the PCB. Overall, I think it was pretty successful.\nSoftware Development\nThis ended up being where the bulk of my time on this project went. It turns out that programming a calculator isn’t as easy as I thought! It turned out to be a great learning experience. At the start of this project I didn’t really have much experience with C programming, but I developed a lot of skills by programming Icarus. The base for the firmware is the wonderful Quantum Mechanical Keyboard Firmware, or QMK. It has a lot of abstraction that makes it easy to get started with your own firmware. Each keyboard has a config that defines its electrical configuration and layout, and then each user can create their own keymaps, with a specific layout to fit them. I assumed that setting up the initial config would be the easy part (as it had been with my previous boards), but I was quickly proved wrong. The first time I plugged in the PCB and flashed it with firmware that I thought was correct, the entire thing hung and became non-responsive. I spent hours debugging before eventually discovering that the quartz clock that I had chosen for the microcontroller was not the same speed as the QMK default. Once I fixed that, it was on to programming the calculator functionality.\nWhile most normal inputs are easy to setup in QMK, I had to program the calculator functionality mostly from scratch. The way I tackled this was to create a togglable layer with custom defined keycodes corresponding to each matrix position. In other words, I defined functions for each key. Most of these functions write to a char array representing the current equation. The ”=” button then calls a function from the TinyExpr library to interpret that buffer into a numeric result, if possible. Pressing enter then sends it to the computer using the qmk “send_string()” function.\nTo make this all more user-friendly, I added a little 128x32 OLED that displays the current expression buffer and expected result as you enter in characters. On the default layer, where you just enter numbers like a numpad, it displays the layout because my keycaps are blank.\nFinal Product\n"},"Blog-Posts/Keyboards/Silvis":{"title":"Silvis","links":["Blog-Posts/Keyboards/Tantalus","Blog-Posts/Keyboards/Dactyl-Manuform-R-Track","Blog-Posts/Keyboards/Icarus"],"tags":["keyboards"],"content":"Silvis\n\nIntroduction\nAfter building Tantalus and another Dactyl Manuform 5x6, I still wasn’t fully satisfied with my secondary keyboard. My Dactyl Manuform R-Track is perfect for my primary setup, but I have been moving around more and doing school work on a laptop. Unfortunately the Dactyl is quite bulky and a little finicky (owing to my amateur soldering job), so it isn’t very mobile.\nI began toying around with ideas for a while. I finally settled on creating another flat keyboard. There would be no mousing device, no curved keywells. I wanted to prioritize the typing experience, above other luxuries. I figure it is better to make the best portable keyboard possible than a mediocre mouse and mediocre keyboard. So from that came Silvis.\nFeature List\n\nCustom PCB with On-board STM32F411 microcontroller\n3D Printed Case designed in Fusion 360\nProgrammable with QMK\nAddressable Per-Key RGB\nUSB-C\nHotswappable Cherry MX keys\n\nHardware Development\nPCB\nI designed the Silvis PCB using the KiCad suite, which I’m now pretty adept with. The PCB features an STM32F411 microcontroller, which has 512 Kb of flash and 128 Kb of ram, plenty for a keyboard. The schematic is overall similar to one of my previous projects, Icarus, because I chose the same MCU for both. The biggest difference is that Silvis features per-key SK6812 Mini-E LEDs, which are reversed mounted. This means that you solder them on the back, but they point up through a hole illuminating the keys from below.\nLaying out the components for this PCB proved far more challenging then any of my previous designs. I wanted the design to be symmetric but unibody, with a couple of different angles between columns to match the splay of my hand. Additionally, each and every one of the 58 keys has both an LED and a diode (see here for why) attached to it. Placing that all by hand was… daunting. I knew I would make a mistake. So I started looking into ways to do it programmatically instead.\nErgoGen\nErgogen, short for ergonomic keyboard generator, is a Javascript project that allows you to describe a 2D keyboard layout using a YAML config, and then generate design files, including plate SVGs, PCBs, and even cases, from there. This allows for a much faster workflow, by tweaking code instead of manually shifting keys in KiCad. I used ErgoGen to place the switches, diodes, and LEDs for the Silvis matrix. I’m a huge fan of this project, and strongly suggest it to anyone looking to make their own ergonomic keyboard.\nCase Design\nI wanted Silvis to be able to hold up to abuse. I wanted a rigid case with a durable design. Of course, for those purposes, a 3D printed case probably wasn’t my best choice, but its what I had to work with.\nThe overall design is pretty simple. I have a 3d-printed shell that the PCB drops down into, then a FR4 plate goes over that, with 10 M3 screws holding everything together. I designed all of this in Fusion360.\nSoftware Development\nSoftware for this project was really easy. Over my past keyboard projects I have developed a strong understanding of QMK, so that is what I chose to use again. The only tricky part was configuring the LEDs to work properly.\nUsage\nI’ve now been using Silvis as my daily driver for about 6 months, and it is wonderful. All of my tedious design work really did pay off."},"Blog-Posts/Keyboards/Tantalus":{"title":"Tantalus","links":["Research/Ergonomic-Mechanical-Keyboards/Ergonomic-Keyboards","Blog-Posts/Keyboards/Dactyl-Manuform-R-Track","Concepts/Programming/Programming-Languages/C-and-CPP/QMK","Research/Ergonomic-Mechanical-Keyboards/KiCad"],"tags":["keyboards"],"content":"Tantalus\nIntroduction\nThis is my 3rd ergonomic keyboard, and my first completely custom design. My previous build, the Dactyl Manuform R-Track, was almost perfect. However I needed another board for my second setup, and really didn’t want to handwire again. So, I set about learning how to design my own 3d models and create my own PCBs. I had a couple goals in mind:\n\nFully Programmable with QMK\n38 Choc Keys with a layout optimized for prose\nCustom PCB with integrated MCU\nUSB-C Connection\nTrackball on a daughterboard\n\nI achieved most of these goals, but in practice it isn’t perfect.\nHardware Development\nThis project was a great learning experience for a number of reasons, but the big one is that I got very acquainted with KiCad, an open source PCB design tool. From scratch, I learned how to create schematics, modify and design footprints, layout a PCB, route a PCB, and read datasheets. Since this was my first design, I kept it somewhat simple. No LEDs, no OLED, no split board, none of the other possible bells and whistles for QMK boards.\nInstead of using a separate daughterboard for the microcontroller as I had on my previous two builds, Tantalus has an ATMEGA32U4 directly on the PCB, along with all of the clock and voltage regulating circuity that entails. This enables me to have a USB-C connection anywhere else on the PCB.\nAnd the PCB Layout:\n\nOnce I finished the PCB, I set to work learning another tool from the ground up: AutoDesk Fusion 360. I needed to create a 3d printable enclosure for the PCB, with a spot for the trackball. I severely underestimated how hard it’d be. After many, many iterations, here is a render of the final design:\n\nAssembly\nI had the PCB manufactured and partially soldered by JLCPCB. Once I had soldered the rest of the components and printed the case, it came time to assemble everything. Unfortunately, everything didn’t go to plan. Some of the tolerances on the case were bad, the wiring was tight, and the trackball sensor interefered with the case closing. Additionally, I made a couple small mistakes on the PCB that rendered two keys non-functional, until I ran jumper wires to fix it. However, with a bit of gumption and a dremel, I was eventually able to get everything fitting and the case to close.\nFinal Product\nWithout further adue, here is how it turned out:\n\nAnd the internals:\n\nIs it janky? Yes. Did I make mistakes? Yes. Am I happy with the final product? Not really. Am I glad I did it? Absolutely. This was a great learning experience."},"Blog-Posts/Posts/BWSI":{"title":"Beaver Works Summer Institute","links":[],"tags":[],"content":"Beaver Works Summer Institute\nIntroduction\nIn the summer of 2023, I had the pleasure of attending the Beaver Works Summer Institute, a program for rising high school seniors run by MIT. It offers the brightest students in the nation the chance to work on fascinating engineering projects with courses taught by MIT faculty.\nI chose to take the Autonomous Underwater Vehicle Challenge, where we learned to take a remotely operated underwater robot and transform it into something fully autonomous using sensor data, computer vision, and motor control. Here is what our robot looked like:\n\nPhysics\nThe first step on our journey to autonomy was understanding how the robot moves in the water. It has a 6 thruster configuration, with 4 on the xy plane and 2 for vertical movement. This allows us full control in all 3 dimensions. You can turn the robot (yaw) by turning on opposing horizontal thrusters. We didn’t really bother with pitch and roll, but you should be able to control those to. In order to understand how the robot actually moves, you have to do just a little bit of linear algebra. Thinking only in the 2D plane, you can find the horizontal and vertical components of each thruster using basic trigonometry. You can do the same to calculate torque, assuming you know the dimensions of the robot. Once you have the components relative to the AUV, you can translate them into the global plane using a rotation matrix. Now that calculation only gives us the acceleration of the AUV. You really want the expected position, so you have to integrate twice. This math formed the basis of our first week of study.\nMotor Control\nNow that we had an idea as to how the robot would respond, it was time to learn how to actually control it. We did so using the PID control model, which relies on an error and the change in that error over time in order to calculate how much to change by. Essentially, the speed of the motors depends on how far away from your target you are, and how quickly that distance is changing. This prevents you from overshooting. The code for this is actually exceedingly simple, but the bulk of the work came from testing it on our actual robots and honing in on the gain values.\nComputer Vision\nOkay, so we can control our robot and make it go where we want to now. How do we know, autonomously, where to go? The same way you do: with vision! Our robot is equipped with a high resolution, high refresh rate camera. You can process that image to gather data about the surroundings, and then decide where to go accordingly. For us, we had to main modes of travel: following April Tags (basically QR codes for robots), or following the lane of a pool. April tags stand out quite a bit an image, so they are pretty easy to find and follow. They give a lot of information based on their size in the image, so you can actually follow them pretty accurately. Pool lanes are a lot harder. They are just dark edges at the bottom of the pool, and there is often times multiple of them in the image, so it can be very difficult to detect them all and pick the right one. I would say that this problem is where the bulk of my development work went throughout the 4 week program."},"Blog-Posts/Posts/Biking":{"title":"Biking","links":[],"tags":[],"content":"Biking\nResearch\nAs winter settled in and I began to spend more time inside, I was looking to get into a new excerise hobby. I spent a while thinking about it, and eventually decided that I wanted to start biking. I’ve known how to ride a bike for a long time, but I’ve never really had a good one, and never really gone on wrong rides. But after discovering the world of bikepacking and seeing all kinds of adventures documented on YouTube, I decided I was going to get into it. So, I spent about a month looking into all kinds of bikes, from sleek and modern road bikes to full-suspension mountain bikes. I learned a lot from that research. For one, bikes are expensive. There are also a lot of options. There’s suspension, drive trains, rim versus disc brakes, dropbar versus flatbar, and countless other of decisions to make before purchasing a bike. But, eventually, I started to develop an idea of what I wanted.\nThe Poseidon X\nThe bike I settled on, and purchased in December 2022, is the Poseidon X. It is a gravel bike, built for rougher terrain (like on gravel roads!) but not neccarisly bumpy and steep trails like you might tackle on a mountain bike. This seems like a good compromise for me, because I will be doing likely 80-90% of my riding on roads, even if I am excited to get on trails come summer. It is a rigid bike, meaning no front or rear suspension. This makes it easier to maintain and cheaper to purchase. It has a 1x10 cassette, which still offers plenty of range for tackling hills or going downhill.\nAs of January, I haven’t been able to go on any long rides yet due to cold weather. But, from the ~10 mile days I have done, the bike is excellent! Its a blast to ride, with smooth gear shifting, lots of braking power, and good ergonomics. I’m really happy with it!"},"Blog-Posts/Posts/Obsidian":{"title":"Obsidian Notes","links":[],"tags":[],"content":"Obsidian Notes\nWhat is Obsidian?\nIn late 2022, I was lucky enough to stumble onto a wonderful project called Obsidian Notes. The principle is simple: a note-taking software composed of plain markdown files with a focus on interconnection and extensibility. You create a folder of markdown files, and use local links, tags, and canvases to connect everything. This allows you to move from file to file as you would thought to thought. It sounds simple, but is extremely powerful in practice.\nBut… why?\nI was skeptical at first too. People online speak of note software like Obsidian as if they will completly change your life, and I didn’t believe them. But, now that I have been using Obsidian for about 3 months, it really does have a big impact on my workflow and thought proccesses. Essentially, whenever I learn a new concept or have an interesting thought I expect to revisit, I write it down in my Obsidian vault, often in shorthand at first. Then, when I have time later, I can expand it fully. Next time I think about that thing, I can just look at my note to refresh my memory. This can also serve as a to-do list; when you think of something you need to do, just write it down. Maybe tag it. Then you come back later. It has a huge impact on my ability to get things done. Fleeting thoughts become reality a lot more now that I use Obsidian.\nDaily Notes\nThe very first place I write down most of these notes and thoughts is my daily note. A daily note is simply a file that you create each day with the date. From my daily notes I can get to everything I worked or thought about that day. In Obsidian, if you want to create a new file, you just write [[$file_name$]], and then hit Ctrl+Enter. This file will then have a “backlink” to your daily note, which can later be viewed graphically. This allows you to visualize ideas and thoughts on a graph, and follow your train of thoughts. This is especially powerful when you return to a project or idea after a long time.\nTags\nAnother hugely important feature of Obsidian is tags. I use tags just as topics. So if I make a file about a physics topic, I just tag it with physics. This can be done in two ways:\n\nInline tags\nYAML Frontmatter\n\nInline tags are just written like#topic directly in your markdown. These are fast to make, but produce visual clutter. YAML Frontmatter tags are written at the very top of the file, like this:\n---\ntags: [xxxxx, yyyyy]\n---\n\nBoth methods work with the other, so you can use whatever you want depending on the note. I tend to use inline tags in my daily notes, but YAML frontmatter for when I extract something to its own file.\nGraph View\nI mentioned the graph view, but I just wanted to give you a visual of what that looks like:\n\nThat is a screenshot of my main Obsidian vault, with over 500 notes. It gives a clear visual of how ideas and tags are related. Most of the grouping comes from tags, but those can be disabled to get a direct view of file-to-file connections, if that is what you are looking for. Its really interesting to visualize what you have learned and thought about for the past months.\nSyncing\nA conventional note-taking approach would involve a notebook, that you can take around with you and write things down in. Obsidian is digital, and not even natively in the cloud. So what do I do if I’m out and about and want to write something down? Well, the way I see it, there are two options:\n\nSync your vault across devices\nTake intermediary notes on another device\n\nI use a mix of both. Sometimes I will write things down on scraps of paper and fold them up in my pocket. Other times, I will write them using Obsidian for my phone (yes, its cross platform!).\nThere are a couple ways to sync a vault from your phone to laptop or similar. Obsidian themselves offer a service called Obsidian Sync, which is $10 a month for cross-platform cloud syncing with version history. A free approach is to setup a Git/GitHub repository, using the obsidian-git plugin.\nConclusion\nSo, I implore you: take a look at Obsidian. It might not be for you, and that’s fine, but if you have ever wanted to try out a note taking software, I truly believe that Obsidian is the best option available."},"index":{"title":"Hello, World","links":["PublicMedia/Resume.pdf","Blog-Posts/Keyboards/Silvis"],"tags":[],"content":"Hello, World\nHey there! I am Eben Quenneville, a Physics student at the University of New Hampshire. This is a publicly accessible sub-section of my personal notes network built using Obsidian.\nThis website is meant to be an easy place for me to publish anything I’ve been thinking about. This will be for my own reference and anyone else stumbling through.\nYou should check out my resume, or a cool project."}}